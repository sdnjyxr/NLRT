
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>Tensors</title><meta name="generator" content="MATLAB 9.4"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2021-01-13"><meta name="DC.source" content="tensor_doc.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:90%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:12px; color:#000; line-height:140%; background:#fff none; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:2.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }
.banner{ background-color:#15243c; text-align:center;}
.navigate {font-size:0.8em; padding:0px; line-height:100%; }

pre, code { font-size:14px; }
tt { font-size: 1.0em; font-weight:bold; background:#f7f7f7; padding-right:5px; padding-left:5px }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:20px 0px 0px; border-top:1px dotted #878787; font-size:0.9em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; padding:0px 20px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="banner"><a href="index.html"><img src="Tensor-Toolbox-for-MATLAB-Banner.png"></a></div><div class="content"><h1>Tensors</h1><!--introduction--><p>
<p class="navigate">
&#62;&#62; <a href="index.html">Tensor Toolbox</a>
&#62;&#62; <a href="tensor_types.html">Tensor Types</a>
&#62;&#62; <a href="tensor_doc.html">Tensors (dense)</a>
</p>
</p><p>Tensors are extensions of multidimensional arrays with additional operations defined on them. Here we explain the <tt>tensor</tt> class, for storing dense tensors, and the basics of creating and working with tensors. The <tt>tensor</tt> class is best described in the following reference:</p><div><ul><li>B. W. Bader and T. G. Kolda. Algorithm 862: MATLAB Tensor Classes for Fast Algorithm Prototyping, ACM Trans. Mathematical Software, 32:635-653, 2006. <a href="http://dx.doi.org/10.1145/1186785.1186794">http://dx.doi.org/10.1145/1186785.1186794</a>.</li></ul></div><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">Creating a tensor from an array</a></li><li><a href="#3">Creating a one-dimensional tensor</a></li><li><a href="#5">Specifying trailing singleton dimensions in a tensor</a></li><li><a href="#8">The constituent parts of a tensor</a></li><li><a href="#10">Creating a tensor from its constituent parts</a></li><li><a href="#11">Creating an empty tensor</a></li><li><a href="#12">Use tenone to create a tensor of all ones</a></li><li><a href="#13">Use tenzeros to create a tensor of all zeros</a></li><li><a href="#14">Use tenrand to create a random tensor</a></li><li><a href="#15">Use squeeze to remove singleton dimensions from a tensor</a></li><li><a href="#16">Use double to convert a tensor to a (multidimensional) array</a></li><li><a href="#18">Use ndims and size to get the size of a tensor</a></li><li><a href="#21">Subscripted reference for a tensor</a></li><li><a href="#29">Subscripted assignment for a tensor</a></li><li><a href="#34">Using end for the last array index.</a></li><li><a href="#37">Use find for subscripts of nonzero elements of a tensor</a></li><li><a href="#41">Computing the Frobenius norm of a tensor</a></li><li><a href="#42">Using reshape to rearrange elements in a tensor</a></li><li><a href="#43">Basic operations (plus, minus, and, or, etc.) on a tensor</a></li><li><a href="#65">Using tenfun for elementwise operations on one or more tensors</a></li><li><a href="#68">Use permute to reorder the modes of a tensor</a></li><li><a href="#71">Symmetrizing and checking for symmetry in a tensor</a></li><li><a href="#74">Displaying a tensor</a></li></ul></div><h2 id="1">Creating a tensor from an array</h2><p>The <tt>tensor</tt> command converts a (multidimensional) array to a tensor object.</p><pre class="codeinput">M = ones(4,3,2); <span class="comment">%&lt;-- A 4 x 3 x 2 array.</span>
X = tensor(M) <span class="comment">%&lt;-- Convert to a tensor object.</span>
</pre><pre class="codeoutput">X is a tensor of size 4 x 3 x 2
	X(:,:,1) = 
	     1     1     1
	     1     1     1
	     1     1     1
	     1     1     1
	X(:,:,2) = 
	     1     1     1
	     1     1     1
	     1     1     1
	     1     1     1
</pre><p>Optionally, you can specify a different shape for the tensor, so long as the input array has the right number of elements.</p><pre class="codeinput">X = tensor(M,[2 3 4]) <span class="comment">%&lt;-- M has 24 elements.</span>
</pre><pre class="codeoutput">X is a tensor of size 2 x 3 x 4
	X(:,:,1) = 
	     1     1     1
	     1     1     1
	X(:,:,2) = 
	     1     1     1
	     1     1     1
	X(:,:,3) = 
	     1     1     1
	     1     1     1
	X(:,:,4) = 
	     1     1     1
	     1     1     1
</pre><h2 id="3">Creating a one-dimensional tensor</h2><p>The tensor class explicitly supports order-one tensors as well as trailing singleton dimensions, but the size must be explicit in the constructor. By default, a column array produces a 2-way tensor.</p><pre class="codeinput">X = tensor(rand(5,1)) <span class="comment">%&lt;-- Creates a 2-way tensor.</span>
</pre><pre class="codeoutput">X is a tensor of size 5 x 1
	X(:,:) = 
	    0.3418
	    0.4071
	    0.8515
	    0.5177
	    0.1050
</pre><p>This is fixed by specifying the size explicitly.</p><pre class="codeinput">X = tensor(rand(5,1),5) <span class="comment">%&lt;-- Creates a 1-way tensor.</span>
</pre><pre class="codeoutput">X is a tensor of size 5
	X(:) = 
	    0.8357
	    0.7066
	    0.7186
	    0.3915
	    0.4511
</pre><h2 id="5">Specifying trailing singleton dimensions in a tensor</h2><p>Likewise, trailing singleton dimensions must be explictly specified.</p><pre class="codeinput">Y = tensor(rand(4,3,1)) <span class="comment">%&lt;-- Creates a 2-way tensor.</span>
</pre><pre class="codeoutput">Y is a tensor of size 4 x 3
	Y(:,:) = 
	    0.5728    0.3852    0.5103
	    0.1321    0.6371    0.5774
	    0.9553    0.1920    0.5068
	    0.6244    0.1059    0.3371
</pre><pre class="codeinput">Y = tensor(rand(4,3,1),[4 3 1]) <span class="comment">%&lt;-- Creates a 3-way tensor.</span>
</pre><pre class="codeoutput">Y is a tensor of size 4 x 3 x 1
	Y(:,:,1) = 
	    0.5257    0.0709    0.9211
	    0.3287    0.9804    0.1935
	    0.2397    0.4832    0.8640
	    0.2543    0.6887    0.0432
</pre><p>Unfortunately, the <tt>whos</tt> command does not report the size of 1D objects correctly (last checked for MATLAB 2006a).</p><pre class="codeinput">whos <span class="string">X</span> <span class="string">Y</span> <span class="comment">%&lt;-- Doesn't report the right size for X!</span>
</pre><pre class="codeoutput">  Name      Size             Bytes  Class     Attributes

  X         1x1                400  tensor              
  Y         4x3x1              472  tensor              

</pre><h2 id="8">The constituent parts of a tensor</h2><pre class="codeinput">X = tenrand([4 3 2]); <span class="comment">%&lt;-- Create data.</span>
X.data <span class="comment">%&lt;-- The array.</span>
</pre><pre class="codeoutput">ans(:,:,1) =
    0.3450    0.7667    0.4278
    0.3065    0.7736    0.3163
    0.1382    0.4086    0.6421
    0.2251    0.8200    0.3803
ans(:,:,2) =
    1.0000    0.6801    0.6244
    0.3067    0.3762    0.9555
    0.6011    0.7601    0.6332
    0.4173    0.1904    0.4562
</pre><pre class="codeinput">X.size <span class="comment">%&lt;-- The size.</span>
</pre><pre class="codeoutput">ans =
     4     3     2
</pre><h2 id="10">Creating a tensor from its constituent parts</h2><pre class="codeinput">Y = tensor(X.data,X.size) <span class="comment">%&lt;-- Copies X.</span>
</pre><pre class="codeoutput">Y is a tensor of size 4 x 3 x 2
	Y(:,:,1) = 
	    0.3450    0.7667    0.4278
	    0.3065    0.7736    0.3163
	    0.1382    0.4086    0.6421
	    0.2251    0.8200    0.3803
	Y(:,:,2) = 
	    1.0000    0.6801    0.6244
	    0.3067    0.3762    0.9555
	    0.6011    0.7601    0.6332
	    0.4173    0.1904    0.4562
</pre><h2 id="11">Creating an empty tensor</h2><p>An empty constructor exists, primarily to support loading previously saved data in MAT-files.</p><pre class="codeinput">X = tensor <span class="comment">%&lt;-- Creates an empty tensor.</span>
</pre><pre class="codeoutput">X is a tensor of size [empty tensor]
	X = []
</pre><h2 id="12">Use tenone to create a tensor of all ones</h2><pre class="codeinput">X = tenones([3 4 2]) <span class="comment">%&lt;-- Creates a 3 x 4 x 2 tensor of ones.</span>
</pre><pre class="codeoutput">X is a tensor of size 3 x 4 x 2
	X(:,:,1) = 
	     1     1     1     1
	     1     1     1     1
	     1     1     1     1
	X(:,:,2) = 
	     1     1     1     1
	     1     1     1     1
	     1     1     1     1
</pre><h2 id="13">Use tenzeros to create a tensor of all zeros</h2><pre class="codeinput">X = tenzeros([1 4 2]) <span class="comment">%&lt;-- Creates a 1 x 4 x 2 tensor of zeros.</span>
</pre><pre class="codeoutput">X is a tensor of size 1 x 4 x 2
	X(:,:,1) = 
	     0     0     0     0
	X(:,:,2) = 
	     0     0     0     0
</pre><h2 id="14">Use tenrand to create a random tensor</h2><pre class="codeinput">X = tenrand([5 4 2]) <span class="comment">%&lt;-- Creates a random 5 x 4 x 2 tensor.</span>
</pre><pre class="codeoutput">X is a tensor of size 5 x 4 x 2
	X(:,:,1) = 
	    0.7608    0.5490    0.7244    0.0279
	    0.3722    0.4983    0.1113    0.9805
	    0.4261    0.2323    0.8601    0.3572
	    0.1441    0.2274    0.2960    0.2537
	    0.7464    0.9448    0.8614    0.8004
	X(:,:,2) = 
	    0.3722    0.4194    0.2726    0.8014
	    0.5129    0.8108    0.6182    0.6885
	    0.3167    0.1195    0.8916    0.0464
	    0.9612    0.4022    0.9491    0.2689
	    0.8488    0.5775    0.7752    0.5743
</pre><h2 id="15">Use squeeze to remove singleton dimensions from a tensor</h2><pre class="codeinput">squeeze(Y) <span class="comment">%&lt;-- Removes singleton dimensions.</span>
</pre><pre class="codeoutput">ans is a tensor of size 4 x 3 x 2
	ans(:,:,1) = 
	    0.3450    0.7667    0.4278
	    0.3065    0.7736    0.3163
	    0.1382    0.4086    0.6421
	    0.2251    0.8200    0.3803
	ans(:,:,2) = 
	    1.0000    0.6801    0.6244
	    0.3067    0.3762    0.9555
	    0.6011    0.7601    0.6332
	    0.4173    0.1904    0.4562
</pre><h2 id="16">Use double to convert a tensor to a (multidimensional) array</h2><pre class="codeinput">double(Y) <span class="comment">%&lt;-- Converts Y to a standard MATLAB array.</span>
</pre><pre class="codeoutput">ans(:,:,1) =
    0.3450    0.7667    0.4278
    0.3065    0.7736    0.3163
    0.1382    0.4086    0.6421
    0.2251    0.8200    0.3803
ans(:,:,2) =
    1.0000    0.6801    0.6244
    0.3067    0.3762    0.9555
    0.6011    0.7601    0.6332
    0.4173    0.1904    0.4562
</pre><pre class="codeinput">Y.data <span class="comment">%&lt;-- Same thing.</span>
</pre><pre class="codeoutput">ans(:,:,1) =
    0.3450    0.7667    0.4278
    0.3065    0.7736    0.3163
    0.1382    0.4086    0.6421
    0.2251    0.8200    0.3803
ans(:,:,2) =
    1.0000    0.6801    0.6244
    0.3067    0.3762    0.9555
    0.6011    0.7601    0.6332
    0.4173    0.1904    0.4562
</pre><h2 id="18">Use ndims and size to get the size of a tensor</h2><pre class="codeinput">ndims(Y) <span class="comment">%&lt;-- Number of dimensions (or ways).</span>
</pre><pre class="codeoutput">ans =
     3
</pre><pre class="codeinput">size(Y) <span class="comment">%&lt;-- Row vector with the sizes of all dimension.</span>
</pre><pre class="codeoutput">ans =
     4     3     2
</pre><pre class="codeinput">size(Y,3) <span class="comment">%&lt;-- Size of a single dimension.</span>
</pre><pre class="codeoutput">ans =
     2
</pre><h2 id="21">Subscripted reference for a tensor</h2><pre class="codeinput">X = tenrand([3 4 2 1]); <span class="comment">%&lt;-- Create a 3 x 4 x 2 x 1 random tensor.</span>
X(1,1,1,1) <span class="comment">%&lt;-- Extract a single element.</span>
</pre><pre class="codeoutput">ans =
    0.2993
</pre><p>It is possible to extract a subtensor that contains a single element. Observe that singleton dimensions are <b>not</b> dropped unless they are specifically specified, e.g., as above.</p><pre class="codeinput">X(1,1,1,:) <span class="comment">%&lt;-- Produces a tensor of order 1 and size 1.</span>
</pre><pre class="codeoutput">ans is a tensor of size 1
	ans(:) = 
	    0.2993
</pre><p>In general, specified dimensions are dropped from the result. Here we specify the second and third dimension.</p><pre class="codeinput">X(:,1,1,:) <span class="comment">%&lt;-- Produces a tensor of size 3 x 1.</span>
</pre><pre class="codeoutput">ans is a tensor of size 3 x 1
	ans(:,:) = 
	    0.2993
	    0.1279
	    0.5671
</pre><p>Moreover, the subtensor is automatically renumbered/resized in the same way that MATLAB works for arrays except that singleton dimensions are handled explicitly.</p><pre class="codeinput">X(1:2,[2 4],1,:) <span class="comment">%&lt;-- Produces a tensor of size 2 x 2 x 1.</span>
</pre><pre class="codeoutput">ans is a tensor of size 2 x 2 x 1
	ans(:,:,1) = 
	    0.1216    0.0483
	    0.1958    0.4250
</pre><p>It's also possible to extract a list of elements by passing in an array of subscripts or a column array of linear indices.</p><pre class="codeinput">subs = [1,1,1,1; 3,4,2,1]; X(subs) <span class="comment">%&lt;-- Extract 2 values by subscript.</span>
</pre><pre class="codeoutput">ans =
    0.2993
    0.9616
</pre><pre class="codeinput">inds = [1; 24]; X(inds) <span class="comment">%&lt;-- Same thing with linear indices.</span>
</pre><pre class="codeoutput">ans =
    0.2993
    0.9616
</pre><p>The difference between extracting a subtensor and a list of linear indices is ambiguous for 1-dimensional tensors. We can specify 'extract' as a second argument whenever we are using a list of subscripts.</p><pre class="codeinput">X = tenrand(10); <span class="comment">%&lt;-- Create a random tensor.</span>
X([1:6]') <span class="comment">%&lt;-- Extract a subtensor.</span>
</pre><pre class="codeoutput">ans is a tensor of size 6
	ans(:) = 
	    0.9403
	    0.0922
	    0.4217
	    0.2784
	    0.2808
	    0.3557
</pre><pre class="codeinput">X([1:6]',<span class="string">'extract'</span>) <span class="comment">%&lt;-- Same thing *but* result is a vector.</span>
</pre><pre class="codeoutput">ans =
    0.9403
    0.0922
    0.4217
    0.2784
    0.2808
    0.3557
</pre><h2 id="29">Subscripted assignment for a tensor</h2><p>We can assign a single element, an entire subtensor, or a list of values for a tensor.</p><pre class="codeinput">X = tenrand([3,4,2]); <span class="comment">%&lt;-- Create some data.</span>
X(1,1,1) = 0 <span class="comment">%&lt;-- Replaces the (1,1,1) element.</span>
</pre><pre class="codeoutput">X is a tensor of size 3 x 4 x 2
	X(:,:,1) = 
	         0    0.5306    0.1162    0.5558
	    0.0012    0.1578    0.9295    0.7267
	    0.2656    0.7179    0.3484    0.5984
	X(:,:,2) = 
	    0.7526    0.4103    0.9115    0.7983
	    0.0381    0.0838    0.2455    0.4370
	    0.4041    0.5799    0.4866    0.7407
</pre><pre class="codeinput">X(1:2,1:2,1) = ones(2,2) <span class="comment">%&lt;-- Replaces a 2 x 2 subtensor.</span>
</pre><pre class="codeoutput">X is a tensor of size 3 x 4 x 2
	X(:,:,1) = 
	    1.0000    1.0000    0.1162    0.5558
	    1.0000    1.0000    0.9295    0.7267
	    0.2656    0.7179    0.3484    0.5984
	X(:,:,2) = 
	    0.7526    0.4103    0.9115    0.7983
	    0.0381    0.0838    0.2455    0.4370
	    0.4041    0.5799    0.4866    0.7407
</pre><pre class="codeinput">X([1 1 1;1 1 2]) = [5;7] <span class="comment">%&lt;-- Replaces the (1,1,1) and (1,1,2)</span>
			 <span class="comment">%elements.</span>
</pre><pre class="codeoutput">X is a tensor of size 3 x 4 x 2
	X(:,:,1) = 
	    5.0000    1.0000    0.1162    0.5558
	    1.0000    1.0000    0.9295    0.7267
	    0.2656    0.7179    0.3484    0.5984
	X(:,:,2) = 
	    7.0000    0.4103    0.9115    0.7983
	    0.0381    0.0838    0.2455    0.4370
	    0.4041    0.5799    0.4866    0.7407
</pre><pre class="codeinput">X([1;13]) = [5;7] <span class="comment">%&lt;-- Same as above using linear indices.</span>
</pre><pre class="codeoutput">X is a tensor of size 3 x 4 x 2
	X(:,:,1) = 
	    5.0000    1.0000    0.1162    0.5558
	    1.0000    1.0000    0.9295    0.7267
	    0.2656    0.7179    0.3484    0.5984
	X(:,:,2) = 
	    7.0000    0.4103    0.9115    0.7983
	    0.0381    0.0838    0.2455    0.4370
	    0.4041    0.5799    0.4866    0.7407
</pre><p>It is possible to <b>grow</b> the tensor automatically by assigning elements outside the original range of the tensor.</p><pre class="codeinput">X(1,1,3) = 1 <span class="comment">%&lt;-- Grows the size of the tensor.</span>
</pre><pre class="codeoutput">X is a tensor of size 3 x 4 x 3
	X(:,:,1) = 
	    5.0000    1.0000    0.1162    0.5558
	    1.0000    1.0000    0.9295    0.7267
	    0.2656    0.7179    0.3484    0.5984
	X(:,:,2) = 
	    7.0000    0.4103    0.9115    0.7983
	    0.0381    0.0838    0.2455    0.4370
	    0.4041    0.5799    0.4866    0.7407
	X(:,:,3) = 
	     1     0     0     0
	     0     0     0     0
	     0     0     0     0
</pre><h2 id="34">Using end for the last array index.</h2><pre class="codeinput">X(end,end,end)  <span class="comment">%&lt;-- Same as X(3,4,3).</span>
</pre><pre class="codeoutput">ans =
     0
</pre><pre class="codeinput">X(1,1,1:end-1)  <span class="comment">%&lt;-- Same as X(1,1,1:2).</span>
</pre><pre class="codeoutput">ans is a tensor of size 2
	ans(:) = 
	     5
	     7
</pre><p>It is also possible to use <tt>end</tt> to index past the end of an array.</p><pre class="codeinput">X(1,1,end+1) = 5 <span class="comment">%&lt;-- Same as X(1,1,4).</span>
</pre><pre class="codeoutput">X is a tensor of size 3 x 4 x 4
	X(:,:,1) = 
	    5.0000    1.0000    0.1162    0.5558
	    1.0000    1.0000    0.9295    0.7267
	    0.2656    0.7179    0.3484    0.5984
	X(:,:,2) = 
	    7.0000    0.4103    0.9115    0.7983
	    0.0381    0.0838    0.2455    0.4370
	    0.4041    0.5799    0.4866    0.7407
	X(:,:,3) = 
	     1     0     0     0
	     0     0     0     0
	     0     0     0     0
	X(:,:,4) = 
	     5     0     0     0
	     0     0     0     0
	     0     0     0     0
</pre><h2 id="37">Use find for subscripts of nonzero elements of a tensor</h2><p>The <tt>find</tt> function returns a list of nonzero <b>subscripts</b> for a tensor. Note that differs from the standard version, which returns linear indices.</p><pre class="codeinput">X = tensor(floor(3*rand(2,2,2))) <span class="comment">%&lt;-- Generate some data.</span>
</pre><pre class="codeoutput">X is a tensor of size 2 x 2 x 2
	X(:,:,1) = 
	     2     2
	     0     2
	X(:,:,2) = 
	     1     1
	     2     0
</pre><pre class="codeinput">[S,V] = find(X) <span class="comment">%&lt;-- Find all the nonzero subscripts and values.</span>
</pre><pre class="codeoutput">S =
     1     1     1
     1     2     1
     2     2     1
     1     1     2
     2     1     2
     1     2     2
V =
     2
     2
     2
     1
     2
     1
</pre><pre class="codeinput">S = find(X &gt;= 2) <span class="comment">%&lt;-- Find subscripts of values &gt;= 2.</span>
</pre><pre class="codeoutput">S =
     1     1     1
     1     2     1
     2     2     1
     2     1     2
</pre><pre class="codeinput">V = X(S) <span class="comment">%&lt;-- Extract the corresponding values from X.</span>
</pre><pre class="codeoutput">V =
     2
     2
     2
     2
</pre><h2 id="41">Computing the Frobenius norm of a tensor</h2><p><tt>norm</tt> computes the Frobenius norm of a tensor. This corresponds to the Euclidean norm of the vectorized tensor.</p><pre class="codeinput">T = tensor(randn(2,3,3));
norm(T)
</pre><pre class="codeoutput">ans =
    3.2798
</pre><h2 id="42">Using reshape to rearrange elements in a tensor</h2><p><tt>reshape</tt> reshapes a tensor into a given size array. The total number of elements in the tensor cannot change.</p><pre class="codeinput">X = tensor(randi(10,3,2,3));
reshape(X,[3,3,2]);
</pre><h2 id="43">Basic operations (plus, minus, and, or, etc.) on a tensor</h2><p>The tensor object supports many basic operations, illustrated here.</p><pre class="codeinput">A = tensor(floor(3*rand(2,3,2)))
B = tensor(floor(3*rand(2,3,2)))
</pre><pre class="codeoutput">A is a tensor of size 2 x 3 x 2
	A(:,:,1) = 
	     0     0     0
	     0     2     0
	A(:,:,2) = 
	     2     1     0
	     0     2     1
B is a tensor of size 2 x 3 x 2
	B(:,:,1) = 
	     2     1     0
	     1     0     2
	B(:,:,2) = 
	     2     0     1
	     0     0     0
</pre><pre class="codeinput">A &amp; B <span class="comment">%&lt;-- Calls and.</span>
</pre><pre class="codeoutput">ans is a tensor of size 2 x 3 x 2
	ans(:,:,1) = 
	   0   0   0
	   0   0   0
	ans(:,:,2) = 
	   1   0   0
	   0   0   0
</pre><pre class="codeinput">A | B <span class="comment">%&lt;-- Calls or.</span>
</pre><pre class="codeoutput">ans is a tensor of size 2 x 3 x 2
	ans(:,:,1) = 
	   1   1   0
	   1   1   1
	ans(:,:,2) = 
	   1   1   1
	   0   1   1
</pre><pre class="codeinput">xor(A,B) <span class="comment">%&lt;-- Calls xor.</span>
</pre><pre class="codeoutput">ans is a tensor of size 2 x 3 x 2
	ans(:,:,1) = 
	   1   1   0
	   1   1   1
	ans(:,:,2) = 
	   0   1   1
	   0   1   1
</pre><pre class="codeinput">A==B <span class="comment">%&lt;-- Calls eq.</span>
</pre><pre class="codeoutput">ans is a tensor of size 2 x 3 x 2
	ans(:,:,1) = 
	   0   0   1
	   0   0   0
	ans(:,:,2) = 
	   1   0   0
	   1   0   0
</pre><pre class="codeinput">A~=B <span class="comment">%&lt;-- Calls neq.</span>
</pre><pre class="codeoutput">ans is a tensor of size 2 x 3 x 2
	ans(:,:,1) = 
	   1   1   0
	   1   1   1
	ans(:,:,2) = 
	   0   1   1
	   0   1   1
</pre><pre class="codeinput">A&gt;B <span class="comment">%&lt;-- Calls gt.</span>
</pre><pre class="codeoutput">ans is a tensor of size 2 x 3 x 2
	ans(:,:,1) = 
	   0   0   0
	   0   1   0
	ans(:,:,2) = 
	   0   1   0
	   0   1   1
</pre><pre class="codeinput">A&gt;=B <span class="comment">%&lt;-- Calls ge.</span>
</pre><pre class="codeoutput">ans is a tensor of size 2 x 3 x 2
	ans(:,:,1) = 
	   0   0   1
	   0   1   0
	ans(:,:,2) = 
	   1   1   0
	   1   1   1
</pre><pre class="codeinput">A&lt;B <span class="comment">%&lt;-- Calls lt.</span>
</pre><pre class="codeoutput">ans is a tensor of size 2 x 3 x 2
	ans(:,:,1) = 
	   1   1   0
	   1   0   1
	ans(:,:,2) = 
	   0   0   1
	   0   0   0
</pre><pre class="codeinput">A&lt;=B <span class="comment">%&lt;-- Calls le.</span>
</pre><pre class="codeoutput">ans is a tensor of size 2 x 3 x 2
	ans(:,:,1) = 
	   1   1   1
	   1   0   1
	ans(:,:,2) = 
	   1   0   1
	   1   0   0
</pre><pre class="codeinput">~A <span class="comment">%&lt;-- Calls not.</span>
</pre><pre class="codeoutput">ans is a tensor of size 2 x 3 x 2
	ans(:,:,1) = 
	   1   1   1
	   1   0   1
	ans(:,:,2) = 
	   0   0   1
	   1   0   0
</pre><pre class="codeinput">+A <span class="comment">%&lt;-- Calls uplus.</span>
</pre><pre class="codeoutput">ans is a tensor of size 2 x 3 x 2
	ans(:,:,1) = 
	     0     0     0
	     0     2     0
	ans(:,:,2) = 
	     2     1     0
	     0     2     1
</pre><pre class="codeinput">-A <span class="comment">%&lt;-- Calls uminus.</span>
</pre><pre class="codeoutput">ans is a tensor of size 2 x 3 x 2
	ans(:,:,1) = 
	     0     0     0
	     0    -2     0
	ans(:,:,2) = 
	    -2    -1     0
	     0    -2    -1
</pre><pre class="codeinput">A+B <span class="comment">%&lt;-- Calls plus.</span>
</pre><pre class="codeoutput">ans is a tensor of size 2 x 3 x 2
	ans(:,:,1) = 
	     2     1     0
	     1     2     2
	ans(:,:,2) = 
	     4     1     1
	     0     2     1
</pre><pre class="codeinput">A-B <span class="comment">%&lt;-- Calls minus.</span>
</pre><pre class="codeoutput">ans is a tensor of size 2 x 3 x 2
	ans(:,:,1) = 
	    -2    -1     0
	    -1     2    -2
	ans(:,:,2) = 
	     0     1    -1
	     0     2     1
</pre><pre class="codeinput">A.*B <span class="comment">%&lt;-- Calls times.</span>
</pre><pre class="codeoutput">ans is a tensor of size 2 x 3 x 2
	ans(:,:,1) = 
	     0     0     0
	     0     0     0
	ans(:,:,2) = 
	     4     0     0
	     0     0     0
</pre><pre class="codeinput">5*A <span class="comment">%&lt;-- Calls mtimes.</span>
</pre><pre class="codeoutput">ans is a tensor of size 2 x 3 x 2
	ans(:,:,1) = 
	     0     0     0
	     0    10     0
	ans(:,:,2) = 
	    10     5     0
	     0    10     5
</pre><pre class="codeinput">A.^B <span class="comment">%&lt;-- Calls power.</span>
</pre><pre class="codeoutput">ans is a tensor of size 2 x 3 x 2
	ans(:,:,1) = 
	     0     0     1
	     0     1     0
	ans(:,:,2) = 
	     4     1     0
	     1     1     1
</pre><pre class="codeinput">A.^2 <span class="comment">%&lt;-- Calls power.</span>
</pre><pre class="codeoutput">ans is a tensor of size 2 x 3 x 2
	ans(:,:,1) = 
	     0     0     0
	     0     4     0
	ans(:,:,2) = 
	     4     1     0
	     0     4     1
</pre><pre class="codeinput">A.\B <span class="comment">%&lt;-- Calls ldivide.</span>
</pre><pre class="codeoutput">ans is a tensor of size 2 x 3 x 2
	ans(:,:,1) = 
	   Inf   Inf   NaN
	   Inf     0   Inf
	ans(:,:,2) = 
	     1     0   Inf
	   NaN     0     0
</pre><pre class="codeinput">A./2 <span class="comment">%&lt;-- Calls rdivide.</span>
</pre><pre class="codeoutput">ans is a tensor of size 2 x 3 x 2
	ans(:,:,1) = 
	     0     0     0
	     0     1     0
	ans(:,:,2) = 
	    1.0000    0.5000         0
	         0    1.0000    0.5000
</pre><pre class="codeinput">A./B <span class="comment">%&lt;-- Calls rdivide (but beware divides by zero!)</span>
</pre><pre class="codeoutput">ans is a tensor of size 2 x 3 x 2
	ans(:,:,1) = 
	     0     0   NaN
	     0   Inf     0
	ans(:,:,2) = 
	     1   Inf     0
	   NaN   Inf   Inf
</pre><h2 id="65">Using tenfun for elementwise operations on one or more tensors</h2><p>The function <tt>tenfun</tt> applies a specified function to a number of tensors. This can be used for any function that is not predefined for tensors.</p><pre class="codeinput">tenfun(@(x)(x+1),A) <span class="comment">%&lt;-- Increment every element of A by one.</span>
</pre><pre class="codeoutput">ans is a tensor of size 2 x 3 x 2
	ans(:,:,1) = 
	     1     1     1
	     1     3     1
	ans(:,:,2) = 
	     3     2     1
	     1     3     2
</pre><pre class="codeinput">tenfun(@max,A,B) <span class="comment">%&lt;-- Max of A and B, elementwise.</span>
</pre><pre class="codeoutput">ans is a tensor of size 2 x 3 x 2
	ans(:,:,1) = 
	     2     1     0
	     1     2     2
	ans(:,:,2) = 
	     2     1     1
	     0     2     1
</pre><pre class="codeinput">C = tensor(floor(5*rand(2,3,2))) <span class="comment">%&lt;-- Create another tensor.</span>
tenfun(@median,A,B,C) <span class="comment">%&lt;-- Elementwise means for A, B, and C.</span>
</pre><pre class="codeoutput">C is a tensor of size 2 x 3 x 2
	C(:,:,1) = 
	     4     1     0
	     4     2     2
	C(:,:,2) = 
	     3     4     0
	     0     4     0
ans is a tensor of size 2 x 3 x 2
	ans(:,:,1) = 
	     2     1     0
	     1     2     2
	ans(:,:,2) = 
	     2     1     0
	     0     2     0
</pre><h2 id="68">Use permute to reorder the modes of a tensor</h2><pre class="codeinput">X = tensor(1:24,[3 4 2]) <span class="comment">%&lt;-- Create a tensor.</span>
</pre><pre class="codeoutput">X is a tensor of size 3 x 4 x 2
	X(:,:,1) = 
	     1     4     7    10
	     2     5     8    11
	     3     6     9    12
	X(:,:,2) = 
	    13    16    19    22
	    14    17    20    23
	    15    18    21    24
</pre><pre class="codeinput">permute(X,[3 2 1]) <span class="comment">%&lt;-- Reverse the modes.</span>
</pre><pre class="codeoutput">ans is a tensor of size 2 x 4 x 3
	ans(:,:,1) = 
	     1     4     7    10
	    13    16    19    22
	ans(:,:,2) = 
	     2     5     8    11
	    14    17    20    23
	ans(:,:,3) = 
	     3     6     9    12
	    15    18    21    24
</pre><p>Permuting a 1-dimensional tensor works correctly.</p><pre class="codeinput">X = tensor(1:4,4); <span class="comment">%&lt;-- Create a 1-way tensor.</span>
permute(X,1) <span class="comment">%&lt;-- Call permute with *only* one dimension.</span>
</pre><pre class="codeoutput">ans is a tensor of size 4
	ans(:) = 
	     1
	     2
	     3
	     4
</pre><h2 id="71">Symmetrizing and checking for symmetry in a tensor</h2><p>A tensor can be symmetrized in a collection of modes with the command <tt>symmetrize</tt>. The new, symmetric tensor is formed by averaging over all elements in the tensor which are required to be equal.</p><pre class="codeinput">W = tensor(rand(4,4,4));
Y=symmetrize(X);
</pre><p>A second argument can also be passed to <tt>symmetrize</tt> which specifies an array of modes with respect to which the tensor should be symmetrized.</p><pre class="codeinput">X = tensor(rand(3,2,3));
Z = symmetrize(X,[1,3]);
</pre><p>Additionally, one can check for symmetry in tensors with the <tt>issymmetric</tt> function. Similar to <tt>symmetrize</tt>, a collection of modes can be passed as a second argument.</p><pre class="codeinput">issymmetric(Y)
issymmetric(Z,[1,3])
</pre><pre class="codeoutput">ans =
  logical
   1
ans =
  logical
   1
</pre><h2 id="74">Displaying a tensor</h2><p>The function <tt>disp</tt> can be used to display a tensor and correctly displays very small and large elements.</p><pre class="codeinput">X = tensor(1:24,[3 4 2]); <span class="comment">%&lt;-- Create a 3 x 4 x 2 tensor.</span>
X(:,:,1) = X(:,:,1) * 1e15; <span class="comment">%&lt;-- Make the first slice very large.</span>
X(:,:,2) = X(:,:,2) * 1e-15; <span class="comment">%&lt;-- Make the second slice very small.</span>
disp(X)
</pre><pre class="codeoutput">ans is a tensor of size 3 x 4 x 2
	ans(:,:,1) = 
	   1.0e+16 *
	    0.1000    0.4000    0.7000    1.0000
	    0.2000    0.5000    0.8000    1.1000
	    0.3000    0.6000    0.9000    1.2000
	ans(:,:,2) = 
	   1.0e-13 *
	    0.1300    0.1600    0.1900    0.2200
	    0.1400    0.1700    0.2000    0.2300
	    0.1500    0.1800    0.2100    0.2400
</pre><p class="footer">Tensor Toolbox for MATLAB: <a href="index.html">www.tensortoolbox.org</a>.</p></div><!--
##### SOURCE BEGIN #####
%% Tensors
%
% <html>
% <p class="navigate">
% &#62;&#62; <a href="index.html">Tensor Toolbox</a> 
% &#62;&#62; <a href="tensor_types.html">Tensor Types</a> 
% &#62;&#62; <a href="tensor_doc.html">Tensors (dense)</a>
% </p>
% </html>
%
% Tensors are extensions of multidimensional arrays with additional
% operations defined on them. Here we explain the |tensor| class, for
% storing dense tensors, and the basics of creating and working with
% tensors. The |tensor| class is best described in the following
% reference:
%
% * B. W. Bader and T. G. Kolda. Algorithm 862: MATLAB Tensor Classes
% for Fast Algorithm Prototyping, ACM Trans. Mathematical Software,
% 32:635-653, 2006. <http://dx.doi.org/10.1145/1186785.1186794>. 
%
%% Creating a tensor from an array
% The |tensor| command converts a (multidimensional) array to a tensor
% object.
M = ones(4,3,2); %<REPLACE_WITH_DASH_DASH A 4 x 3 x 2 array.
X = tensor(M) %<REPLACE_WITH_DASH_DASH Convert to a tensor object.
%%
% Optionally, you can specify a different shape for the tensor, so
% long as the input array has the right number of elements.
X = tensor(M,[2 3 4]) %<REPLACE_WITH_DASH_DASH M has 24 elements.
%% Creating a one-dimensional tensor
% The tensor class explicitly supports order-one tensors as well as
% trailing singleton dimensions, but the size must be explicit in the
% constructor. By default, a column array produces a 2-way tensor.
X = tensor(rand(5,1)) %<REPLACE_WITH_DASH_DASH Creates a 2-way tensor.
%%
% This is fixed by specifying the size explicitly.
X = tensor(rand(5,1),5) %<REPLACE_WITH_DASH_DASH Creates a 1-way tensor.
%% Specifying trailing singleton dimensions in a tensor
% Likewise, trailing singleton dimensions must be explictly specified.
Y = tensor(rand(4,3,1)) %<REPLACE_WITH_DASH_DASH Creates a 2-way tensor.
%%
Y = tensor(rand(4,3,1),[4 3 1]) %<REPLACE_WITH_DASH_DASH Creates a 3-way tensor.
%%
% Unfortunately, the |whos| command does not report the size of 1D
% objects correctly (last checked for MATLAB 2006a).
whos X Y %<REPLACE_WITH_DASH_DASH Doesn't report the right size for X!
%% The constituent parts of a tensor
X = tenrand([4 3 2]); %<REPLACE_WITH_DASH_DASH Create data.
X.data %<REPLACE_WITH_DASH_DASH The array.
%%
X.size %<REPLACE_WITH_DASH_DASH The size.
%% Creating a tensor from its constituent parts
Y = tensor(X.data,X.size) %<REPLACE_WITH_DASH_DASH Copies X.
%% Creating an empty tensor
% An empty constructor exists, primarily to support loading previously
% saved data in MAT-files.
X = tensor %<REPLACE_WITH_DASH_DASH Creates an empty tensor.
%% Use tenone to create a tensor of all ones
X = tenones([3 4 2]) %<REPLACE_WITH_DASH_DASH Creates a 3 x 4 x 2 tensor of ones.
%% Use tenzeros to create a tensor of all zeros
X = tenzeros([1 4 2]) %<REPLACE_WITH_DASH_DASH Creates a 1 x 4 x 2 tensor of zeros.
%% Use tenrand to create a random tensor
X = tenrand([5 4 2]) %<REPLACE_WITH_DASH_DASH Creates a random 5 x 4 x 2 tensor.
%% Use squeeze to remove singleton dimensions from a tensor
squeeze(Y) %<REPLACE_WITH_DASH_DASH Removes singleton dimensions.
%% Use double to convert a tensor to a (multidimensional) array
double(Y) %<REPLACE_WITH_DASH_DASH Converts Y to a standard MATLAB array.
%%
Y.data %<REPLACE_WITH_DASH_DASH Same thing.
%% Use ndims and size to get the size of a tensor
ndims(Y) %<REPLACE_WITH_DASH_DASH Number of dimensions (or ways).
%%
size(Y) %<REPLACE_WITH_DASH_DASH Row vector with the sizes of all dimension.
%%
size(Y,3) %<REPLACE_WITH_DASH_DASH Size of a single dimension.
%% Subscripted reference for a tensor
X = tenrand([3 4 2 1]); %<REPLACE_WITH_DASH_DASH Create a 3 x 4 x 2 x 1 random tensor.
X(1,1,1,1) %<REPLACE_WITH_DASH_DASH Extract a single element.
%%
% It is possible to extract a subtensor that contains a single
% element. Observe that singleton dimensions are *not* dropped unless
% they are specifically specified, e.g., as above.
X(1,1,1,:) %<REPLACE_WITH_DASH_DASH Produces a tensor of order 1 and size 1.
%%
% In general, specified dimensions are dropped from the result. Here
% we specify the second and third dimension.
X(:,1,1,:) %<REPLACE_WITH_DASH_DASH Produces a tensor of size 3 x 1.
%%
% Moreover, the subtensor is automatically renumbered/resized in the
% same way that MATLAB works for arrays except that singleton
% dimensions are handled explicitly.
X(1:2,[2 4],1,:) %<REPLACE_WITH_DASH_DASH Produces a tensor of size 2 x 2 x 1.
%%
% It's also possible to extract a list of elements by passing in an
% array of subscripts or a column array of linear indices.
subs = [1,1,1,1; 3,4,2,1]; X(subs) %<REPLACE_WITH_DASH_DASH Extract 2 values by subscript.
%%
inds = [1; 24]; X(inds) %<REPLACE_WITH_DASH_DASH Same thing with linear indices.
%%
% The difference between extracting a subtensor and a list of linear
% indices is ambiguous for 1-dimensional tensors. We can specify
% 'extract' as a second argument whenever we are using a list of
% subscripts.
X = tenrand(10); %<REPLACE_WITH_DASH_DASH Create a random tensor.
X([1:6]') %<REPLACE_WITH_DASH_DASH Extract a subtensor.
%%
X([1:6]','extract') %<REPLACE_WITH_DASH_DASH Same thing *but* result is a vector.
%% Subscripted assignment for a tensor
% We can assign a single element, an entire subtensor, or a list of
% values for a tensor.
X = tenrand([3,4,2]); %<REPLACE_WITH_DASH_DASH Create some data.
X(1,1,1) = 0 %<REPLACE_WITH_DASH_DASH Replaces the (1,1,1) element.
%%
X(1:2,1:2,1) = ones(2,2) %<REPLACE_WITH_DASH_DASH Replaces a 2 x 2 subtensor.
%%
X([1 1 1;1 1 2]) = [5;7] %<REPLACE_WITH_DASH_DASH Replaces the (1,1,1) and (1,1,2)
			 %elements.
%%
X([1;13]) = [5;7] %<REPLACE_WITH_DASH_DASH Same as above using linear indices.
%%
% It is possible to *grow* the tensor automatically by assigning
% elements outside the original range of the tensor.
X(1,1,3) = 1 %<REPLACE_WITH_DASH_DASH Grows the size of the tensor.
%% Using end for the last array index.
X(end,end,end)  %<REPLACE_WITH_DASH_DASH Same as X(3,4,3).
%%
X(1,1,1:end-1)  %<REPLACE_WITH_DASH_DASH Same as X(1,1,1:2).
%%
% It is also possible to use |end| to index past the end of an array.
X(1,1,end+1) = 5 %<REPLACE_WITH_DASH_DASH Same as X(1,1,4).
%% Use find for subscripts of nonzero elements of a tensor
% The |find| function returns a list of nonzero *subscripts* for a
% tensor. Note that differs from the standard version, which returns
% linear indices.
X = tensor(floor(3*rand(2,2,2))) %<REPLACE_WITH_DASH_DASH Generate some data.
%%
[S,V] = find(X) %<REPLACE_WITH_DASH_DASH Find all the nonzero subscripts and values.
%%
S = find(X >= 2) %<REPLACE_WITH_DASH_DASH Find subscripts of values >= 2.
%%
V = X(S) %<REPLACE_WITH_DASH_DASH Extract the corresponding values from X.
%% Computing the Frobenius norm of a tensor
% |norm| computes the Frobenius norm of a tensor. This corresponds to
% the Euclidean norm of the vectorized tensor.
T = tensor(randn(2,3,3));
norm(T)
%% Using reshape to rearrange elements in a tensor
% |reshape| reshapes a tensor into a given size array. The total
% number of elements in the tensor cannot change.
X = tensor(randi(10,3,2,3));
reshape(X,[3,3,2]);
%% Basic operations (plus, minus, and, or, etc.) on a tensor
% The tensor object supports many basic operations, illustrated here.
A = tensor(floor(3*rand(2,3,2)))
B = tensor(floor(3*rand(2,3,2)))
%%
A & B %<REPLACE_WITH_DASH_DASH Calls and.
%%
A | B %<REPLACE_WITH_DASH_DASH Calls or.
%%
xor(A,B) %<REPLACE_WITH_DASH_DASH Calls xor.
%%
A==B %<REPLACE_WITH_DASH_DASH Calls eq.
%%
A~=B %<REPLACE_WITH_DASH_DASH Calls neq.
%%
A>B %<REPLACE_WITH_DASH_DASH Calls gt.
%%
A>=B %<REPLACE_WITH_DASH_DASH Calls ge.
%%
A<B %<REPLACE_WITH_DASH_DASH Calls lt.
%%
A<=B %<REPLACE_WITH_DASH_DASH Calls le.
%%
~A %<REPLACE_WITH_DASH_DASH Calls not.
%%
+A %<REPLACE_WITH_DASH_DASH Calls uplus.
%%
-A %<REPLACE_WITH_DASH_DASH Calls uminus.
%%
A+B %<REPLACE_WITH_DASH_DASH Calls plus.
%%
A-B %<REPLACE_WITH_DASH_DASH Calls minus.
%%
A.*B %<REPLACE_WITH_DASH_DASH Calls times.
%%
5*A %<REPLACE_WITH_DASH_DASH Calls mtimes.
%%
A.^B %<REPLACE_WITH_DASH_DASH Calls power.
%%
A.^2 %<REPLACE_WITH_DASH_DASH Calls power.
%%
A.\B %<REPLACE_WITH_DASH_DASH Calls ldivide.
%%
A./2 %<REPLACE_WITH_DASH_DASH Calls rdivide.
%%
A./B %<REPLACE_WITH_DASH_DASH Calls rdivide (but beware divides by zero!)
%% Using tenfun for elementwise operations on one or more tensors
% The function |tenfun| applies a specified function to a number of
% tensors. This can be used for any function that is not predefined
% for tensors.
tenfun(@(x)(x+1),A) %<REPLACE_WITH_DASH_DASH Increment every element of A by one.
%%
tenfun(@max,A,B) %<REPLACE_WITH_DASH_DASH Max of A and B, elementwise.
%%
C = tensor(floor(5*rand(2,3,2))) %<REPLACE_WITH_DASH_DASH Create another tensor.
tenfun(@median,A,B,C) %<REPLACE_WITH_DASH_DASH Elementwise means for A, B, and C.
%% Use permute to reorder the modes of a tensor
X = tensor(1:24,[3 4 2]) %<REPLACE_WITH_DASH_DASH Create a tensor.
%%
permute(X,[3 2 1]) %<REPLACE_WITH_DASH_DASH Reverse the modes.
%%
% Permuting a 1-dimensional tensor works correctly.
X = tensor(1:4,4); %<REPLACE_WITH_DASH_DASH Create a 1-way tensor.
permute(X,1) %<REPLACE_WITH_DASH_DASH Call permute with *only* one dimension.
%% Symmetrizing and checking for symmetry in a tensor
% A tensor can be symmetrized in a collection of modes with the
% command |symmetrize|. The new, symmetric tensor is formed by
% averaging over all elements in the tensor which are required to be
% equal.
W = tensor(rand(4,4,4));
Y=symmetrize(X);
%%
% A second argument can also be passed to |symmetrize| which specifies
% an array of modes with respect to which the tensor should be
% symmetrized.
X = tensor(rand(3,2,3));
Z = symmetrize(X,[1,3]);
%%
% Additionally, one can check for symmetry in tensors with the
% |issymmetric| function. Similar to |symmetrize|, a collection of
% modes can be passed as a second argument.
issymmetric(Y)
issymmetric(Z,[1,3])
%% Displaying a tensor
% The function |disp| can be used to display a tensor and correctly
% displays very small and large elements.
X = tensor(1:24,[3 4 2]); %<REPLACE_WITH_DASH_DASH Create a 3 x 4 x 2 tensor.
X(:,:,1) = X(:,:,1) * 1e15; %<REPLACE_WITH_DASH_DASH Make the first slice very large.
X(:,:,2) = X(:,:,2) * 1e-15; %<REPLACE_WITH_DASH_DASH Make the second slice very small.
disp(X)

##### SOURCE END #####
--></body></html>